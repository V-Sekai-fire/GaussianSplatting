[gd_scene load_steps=13 format=3 uid="uid://dvqg33ri1mn0t"]

[ext_resource type="PackedScene" uid="uid://2ohhmwno7h3c" path="res://addons/gaussian_splats/art/gltf_with_grid_instanced.glb" id="1_uw00l"]
[ext_resource type="Material" uid="uid://bonakm4g2gnm4" path="res://addons/gaussian_splats/core/gaussian_splat.tres" id="3_huo0t"]
[ext_resource type="PackedScene" uid="uid://dmsjkrhv0bc66" path="res://addons/gaussian_splats/art/rotations2D_GLTF.glb" id="3_ptdrs"]

[sub_resource type="GDScript" id="GDScript_uw00l"]
script/source = "@tool
extends Node

const GAUSSIAN_SPLAT = preload(\"uid://bonakm4g2gnm4\")

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	pass # Replace with function body.


## 35mm film format image size. https://en.wikipedia.org/wiki/135_film
const film_format_35mm := Vector2(36,24)

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	var image_resolution : Vector2 = get_viewport().size
	var fovy_degrees := get_viewport().get_camera_3d().fov
	
	if Engine.is_editor_hint():
		image_resolution = EditorInterface.get_editor_viewport_3d(0).size
		fovy_degrees = EditorInterface.get_editor_viewport_3d(0).get_camera_3d().fov
		#print(fovy_degrees)
	
	var cropped_frame_mm : Vector2 = GaussianSplattingExtension.get_cropped_sensor_size(film_format_35mm, image_resolution)
	#cropped_frame_mm = film_format_35mm
	
	var focal_length_px : Vector2 = GaussianSplattingExtension.get_camera_focal_length_px(deg_to_rad(fovy_degrees), image_resolution, cropped_frame_mm)
	#focal_length_px = GaussianSplattingExtension.get_camera_focal_length_mm(deg_to_rad(fovy_degrees), cropped_frame_mm) * Vector2(1,1)
	GAUSSIAN_SPLAT.set_shader_parameter(\"u_focal_length\", focal_length_px)
"

[sub_resource type="Shader" id="Shader_uw00l"]
code = "shader_type spatial;

render_mode unshaded;
render_mode cull_disabled;
render_mode skip_vertex_transform;

#define SCREEN_QUAD_OUTPUT
//#define SCREEN_QUAD_WIREFRAME
#include \"res://addons/gaussian_splats/core/shaders/includes/screen_quad_renderer.gdshaderinc\"
#include \"res://addons/gaussian_splats/core/shaders/includes/splat_math.gdshaderinc\"

// Ellipse in quadric form to ellipse in parametric form with major and minor axes
// See https://www.shadertoy.com/view/stS3Ww
void extractEllipse(in float a, in float b, in float c, in float d, in float e, in float f, out mat2 axes, out vec2 size, out vec2 center) {
    center = vec2(2.0 * b * d - c * e, 2.0 * a * e - c * d) / (c * c - 4.0 * a * b);
    float g = a * center.x * center.x + b * center.y * center.y + c * center.x * center.y + d * center.x + e * center.y + f;

    float ba = b - a, r = ba / c;
    float ca = 0.5 * sign(c) / sqrt(1.0 + r * r);
    float ch = sqrt(0.5 + ca), sh = sqrt(0.5 - ca) * sign(ba);
    float i = ch - sh, j = ch + sh;

    float ii = i * i, jj = j * j, ij = c * i * j;
    size = sqrt(-2.0 * g / vec2(a * ii + b * jj + ij, a * jj + b * ii - ij));
    axes = mat2(vec2(i, j), vec2(-j, i)) * sqrt(0.5);
}

// Structures
struct Camera {
    vec3 pos;
    mat3 axes;
    float focal;
};

// Ellipsoid projection
void projEllipsoid(in vec3 pos, in mat3 mat, in Camera cam, out mat2 axes, out vec2 size, out vec2 center) {
    mat3 inv = inverse(mat), view = inv * cam.axes, tview = transpose(view);
    vec3 ro = inv * (cam.pos - pos);

    vec3 vo = tview * ro;
    mat3 vv = tview * view * (dot(ro, ro) - 1.0);

    float a = (vo.x * vo.x - vv[0][0]);
    float b = (vo.y * vo.y - vv[1][1]);
    float c = (vo.x * vo.y - vv[0][1]) * 2.0;
    float d = (vo.x * vo.z - vv[0][2]) * cam.focal * 2.0;
    float e = (vo.y * vo.z - vv[1][2]) * cam.focal * 2.0;
    float f = (vo.z * vo.z - vv[2][2]) * cam.focal * cam.focal;

    extractEllipse(a, b, c, d, e, f, axes, size, center);
}


void vertex() {
	QUAD_VERTEX_BASE = UV;

	QUAD_POS = vec2(VIEWPORT_SIZE/2.0);
	QUAD_DIR = normalize(vec2(1,.2*sin(TIME)));
	QUAD_SIZE = vec2(100, 200);
	QUAD_DEPTH = 0.5;

	mat4 proj = INV_PROJECTION_MATRIX;
	//proj[1].xyz = -proj[1].xyz;
	//proj = CreateClipToViewMatrix(proj, vec4(1,1,1,1));

	Camera cam;
	cam.pos = vec3(0);
	cam.axes = mat3(1);
	cam.focal = 1.0;

	mat4 ellipse_transform = MODELVIEW_MATRIX;
	//Ellipse e = GetProjectedEllipsoid(GODOT_TO_UNITY_MAT4(proj), pos, vec3(1,2,3), vec4(0,0,0,1));

	mat2 axes;
	vec2 size;
	vec2 center;
	projEllipsoid(ellipse_transform[3].xyz, mat3(ellipse_transform), cam, axes, size, center);

	vec4 ndc;
	QUAD_POS = (PROJECTION_MATRIX * vec4(center, 1, 1)).xy / (PROJECTION_MATRIX * vec4(center, 1, 1)).w;
	QUAD_POS = (QUAD_POS * 0.5 + 0.5) * VIEWPORT_SIZE;
	QUAD_DIR = axes[0];
	QUAD_DIR.y *= -1.0;
	QUAD_SIZE = size * 1000.0;

	processQuadVertex();
}

void fragment() {
	ALBEDO = vec3(1);
	ALPHA = 1.0;

	ALBEDO = vec3(UV,0);

	vec2 uv = UV * 2.0 - 1.0;
	float d = length(uv);

	ALPHA = 1.0 - smoothstep(0.0, 1.0, d);

	ALBEDO += clamp(1.0 - abs(d-1.0) / fwidth(d), 0.0, 1.0);
	ALPHA += clamp(1.0 - abs(d-1.0) / fwidth(d), 0.0, 1.0);

	processQuadFragment();

}

//void light() {
//	// Called for every pixel for every light affecting the material.
//	// Uncomment to replace the default light processing function with this one.
//}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_tnp7i"]
render_priority = 0
shader = SubResource("Shader_uw00l")
shader_parameter/debug_screen_quad = false

[sub_resource type="QuadMesh" id="QuadMesh_uw00l"]

[sub_resource type="MultiMesh" id="MultiMesh_tnp7i"]
transform_format = 1
instance_count = 4
mesh = SubResource("QuadMesh_uw00l")
buffer = PackedFloat32Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

[sub_resource type="QuadMesh" id="QuadMesh_tnp7i"]
size = Vector2(2, 2)

[sub_resource type="BoxMesh" id="BoxMesh_uw00l"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_ptdrs"]

[sub_resource type="QuadMesh" id="QuadMesh_huo0t"]

[node name="Scenes" type="Node3D"]

[node name="gltf_with_grid_instanced" parent="." instance=ExtResource("1_uw00l")]
visible = false

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(-0.9999361, 0.002859197, -0.010939123, 0, 0.96749806, 0.25287837, 0.011306609, 0.25286222, -0.96743625, 5.7578177, 88.91049, -277.14102)

[node name="Node" type="Node" parent="."]
script = SubResource("GDScript_uw00l")

[node name="MultiMeshInstance3D" type="MultiMeshInstance3D" parent="."]
visible = false
material_override = SubResource("ShaderMaterial_tnp7i")
multimesh = SubResource("MultiMesh_tnp7i")

[node name="splat" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 2, 0, 0, 0, 3, -393.6268, 0, 0)
material_override = SubResource("ShaderMaterial_tnp7i")
mesh = SubResource("QuadMesh_tnp7i")

[node name="MeshInstance3D2" type="MeshInstance3D" parent="."]
transform = Transform3D(100, 0, 0, 0, 100, 0, 0, 0, 100, 0, 0, 0)
visible = false
mesh = SubResource("BoxMesh_uw00l")

[node name="rotations2D_GLTF" parent="." instance=ExtResource("3_ptdrs")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 21.774044, 176.64052, 430.87918)
visible = false

[node name="Mesh" parent="rotations2D_GLTF" index="0"]
visible = false
material_override = ExtResource("3_huo0t")

[node name="MeshInstance3D3" type="MeshInstance3D" parent="."]
visible = false
material_override = SubResource("ShaderMaterial_ptdrs")
mesh = SubResource("QuadMesh_huo0t")

[editable path="gltf_with_grid_instanced"]
[editable path="rotations2D_GLTF"]
